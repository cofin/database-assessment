/*
PostgreSQL Index Information Collection
Generated: {{ generation_date }}

Copyright {{ copyright_year }} Google LLC
Licensed under the Apache License, Version 2.0
*/

\set ON_ERROR_STOP on
\timing off
\pset format unaligned
\pset tuples_only true
\pset fieldsep '|'

-- Header
SELECT 'pkey',
       'schema_name',
       'table_name',
       'index_name',
       'index_type',
       'is_unique',
       'is_primary',
       'is_exclusion',
       'is_clustered',
       'is_valid',
       'size_bytes',
       'size_pretty',
       'index_def',
       'tablespace',
       'constraint_type',
       'index_columns',
       'index_expressions',
       'index_predicates',
       'dma_source_id',
       'dma_manual_id';

-- Index Information
WITH RECURSIVE
index_columns AS (
    SELECT i.indexrelid,
           string_agg(
               CASE
                   WHEN a.attname IS NOT NULL THEN a.attname
                   ELSE pg_get_indexdef(i.indexrelid, k.n, false)
               END,
               ', ' ORDER BY k.n
           ) AS columns,
           string_agg(
               NULLIF(pg_get_indexdef(i.indexrelid, k.n, true), a.attname),
               ', ' ORDER BY k.n
           ) AS expressions
    FROM pg_index i
    CROSS JOIN LATERAL generate_series(1, i.indnatts) AS k(n)
    LEFT JOIN pg_attribute a ON a.attrelid = i.indrelid
        AND a.attnum = i.indkey[k.n-1]
    GROUP BY i.indexrelid
),
index_stats AS (
    SELECT indexrelid AS oid,
           pg_relation_size(indexrelid) AS size_bytes,
           pg_size_pretty(pg_relation_size(indexrelid)) AS size_pretty
    FROM pg_stat_user_indexes
)
SELECT :'pkey' AS pkey,
       n.nspname AS schema_name,
       ct.relname AS table_name,
       ci.relname AS index_name,
       am.amname AS index_type,
       i.indisunique AS is_unique,
       i.indisprimary AS is_primary,
       i.indisexclusion AS is_exclusion,
       ci.relisclustered AS is_clustered,
       i.indisvalid AS is_valid,
       s.size_bytes,
       s.size_pretty,
       pg_get_indexdef(i.indexrelid) AS index_def,
       COALESCE(t.spcname, 'pg_default') AS tablespace,
       CASE
           WHEN c.contype = 'p' THEN 'PRIMARY KEY'
           WHEN c.contype = 'u' THEN 'UNIQUE'
           WHEN c.contype = 'x' THEN 'EXCLUSION'
           ELSE NULL
       END AS constraint_type,
       ic.columns AS index_columns,
       NULLIF(ic.expressions, ic.columns) AS index_expressions,
       CASE
           WHEN i.indpred IS NOT NULL
           THEN pg_get_expr(i.indpred, i.indrelid)
       END AS index_predicates,
       :'dma_source_id' AS dma_source_id,
       :'dma_manual_id' AS dma_manual_id
FROM pg_index i
JOIN pg_class ci ON ci.oid = i.indexrelid
JOIN pg_class ct ON ct.oid = i.indrelid
JOIN pg_namespace n ON n.oid = ct.relnamespace
JOIN pg_am am ON am.oid = ci.relam
LEFT JOIN pg_tablespace t ON t.oid = ci.reltablespace
LEFT JOIN pg_constraint c ON c.conindid = i.indexrelid
LEFT JOIN index_columns ic ON ic.indexrelid = i.indexrelid
LEFT JOIN index_stats s ON s.oid = i.indexrelid
WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
  AND n.nspname !~ '^pg_toast'
ORDER BY schema_name, table_name, index_name;
