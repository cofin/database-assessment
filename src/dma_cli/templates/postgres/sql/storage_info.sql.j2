/*
PostgreSQL Storage and Tablespace Information Collection
Generated: {{ generation_date }}

Copyright {{ copyright_year }} Google LLC
Licensed under the Apache License, Version 2.0
*/

\set ON_ERROR_STOP on
\timing off
\pset format unaligned
\pset tuples_only true
\pset fieldsep '|'

-- Header: Tablespace Information
SELECT 'pkey',
       'tablespace_name',
       'owner',
       'location',
       'size_bytes',
       'size_pretty',
       'options',
       'object_count',
       'description',
       'dma_source_id',
       'dma_manual_id';

-- Tablespace Information
WITH RECURSIVE
tablespace_objects AS (
    SELECT spcoid,
           count(*) AS object_count
    FROM (
        SELECT c.reltablespace AS spcoid
        FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        WHERE c.reltablespace != 0
          AND n.nspname NOT IN ('pg_catalog', 'information_schema')
          AND n.nspname !~ '^pg_toast'
        UNION ALL
        SELECT d.dattablespace
        FROM pg_database d
        WHERE d.dattablespace != 0
    ) objects
    GROUP BY spcoid
)
SELECT :'pkey' AS pkey,
       spcname AS tablespace_name,
       pg_get_userbyid(spcowner) AS owner,
       pg_tablespace_location(t.oid) AS location,
       pg_tablespace_size(t.oid) AS size_bytes,
       pg_size_pretty(pg_tablespace_size(t.oid)) AS size_pretty,
       array_to_string(reloptions, ', ') AS options,
       COALESCE(o.object_count, 0) AS object_count,
       d.description,
       :'dma_source_id' AS dma_source_id,
       :'dma_manual_id' AS dma_manual_id
FROM pg_tablespace t
LEFT JOIN tablespace_objects o ON t.oid = o.spcoid
LEFT JOIN pg_description d ON d.objoid = t.oid AND d.classoid = 'pg_tablespace'::regclass
ORDER BY spcname;

-- Header: Database File Layout
SELECT 'pkey',
       'schema_name',
       'object_type',
       'object_name',
       'tablespace_name',
       'file_path',
       'size_bytes',
       'size_pretty',
       'relation_filepath',
       'dma_source_id',
       'dma_manual_id';

-- Database File Layout
WITH RECURSIVE
relation_files AS (
    SELECT c.oid,
           n.nspname AS schema_name,
           CASE c.relkind
               WHEN 'r' THEN 'table'
               WHEN 'i' THEN 'index'
               WHEN 't' THEN 'toast'
               WHEN 'm' THEN 'materialized_view'
           END AS object_type,
           c.relname AS object_name,
           COALESCE(t.spcname, 'pg_default') AS tablespace_name,
           pg_relation_filepath(c.oid) AS relation_filepath,
           pg_relation_size(c.oid) AS size_bytes
    FROM pg_class c
    JOIN pg_namespace n ON n.oid = c.relnamespace
    LEFT JOIN pg_tablespace t ON t.oid = c.reltablespace
    WHERE c.relkind IN ('r', 'i', 't', 'm')
      AND n.nspname NOT IN ('pg_catalog', 'information_schema')
      AND n.nspname !~ '^pg_toast'
)
SELECT :'pkey' AS pkey,
       schema_name,
       object_type,
       object_name,
       tablespace_name,
       COALESCE(
           regexp_replace(
               relation_filepath,
               '^pg_tblspc/([0-9]+)/',
               (SELECT 'tablespace_' || spcname || '/' FROM pg_tablespace WHERE oid::text = regexp_replace(relation_filepath, '^pg_tblspc/([0-9]+)/.*', '\1'))
           ),
           relation_filepath
       ) AS file_path,
       size_bytes,
       pg_size_pretty(size_bytes) AS size_pretty,
       relation_filepath,
       :'dma_source_id' AS dma_source_id,
       :'dma_manual_id' AS dma_manual_id
FROM relation_files
ORDER BY schema_name, object_type, object_name;

-- Header: Storage Parameters
SELECT 'pkey',
       'schema_name',
       'object_type',
       'object_name',
       'parameter_name',
       'parameter_value',
       'is_default',
       'dma_source_id',
       'dma_manual_id';

-- Storage Parameters
WITH RECURSIVE
storage_params AS (
    SELECT n.nspname AS schema_name,
           CASE c.relkind
               WHEN 'r' THEN 'table'
               WHEN 'i' THEN 'index'
               WHEN 't' THEN 'toast'
               WHEN 'm' THEN 'materialized_view'
           END AS object_type,
           c.relname AS object_name,
           (each(c.reloptions)).key AS parameter_name,
           (each(c.reloptions)).value AS parameter_value,
           false AS is_default
    FROM pg_class c
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE c.relkind IN ('r', 'i', 't', 'm')
      AND n.nspname NOT IN ('pg_catalog', 'information_schema')
      AND n.nspname !~ '^pg_toast'
      AND c.reloptions IS NOT NULL
    UNION ALL
    SELECT n.nspname AS schema_name,
           CASE c.relkind
               WHEN 'r' THEN 'table'
               WHEN 'i' THEN 'index'
               WHEN 't' THEN 'toast'
               WHEN 'm' THEN 'materialized_view'
           END AS object_type,
           c.relname AS object_name,
           (each(regexp_split_to_array(
               array_to_string(c.reloptions, ','),
               ','
           )::text[])).key AS parameter_name,
           (each(regexp_split_to_array(
               array_to_string(c.reloptions, ','),
               ','
           )::text[])).value AS parameter_value,
           true AS is_default
    FROM pg_class c
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE c.relkind IN ('r', 'i', 't', 'm')
      AND n.nspname NOT IN ('pg_catalog', 'information_schema')
      AND n.nspname !~ '^pg_toast'
      AND c.reloptions IS NULL
)
SELECT :'pkey' AS pkey,
       schema_name,
       object_type,
       object_name,
       parameter_name,
       parameter_value,
       is_default,
       :'dma_source_id' AS dma_source_id,
       :'dma_manual_id' AS dma_manual_id
FROM storage_params
WHERE parameter_name IS NOT NULL
ORDER BY schema_name, object_type, object_name, parameter_name;
